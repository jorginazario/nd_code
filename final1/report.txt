Juan Pablo Borrero & Jorge Nazario
CSE 20311
Final Project

report.txt

-- What your program is meant to do, from the user's perspective:

From the user's perspective, this is a spaceship arcade game! 
The game rules are simple: click 'a' or left arrow to move ship to the left, click 'd' or right arrow to move your ship to the right, and click the 'space' to shoot at your targets. Your objective is to shoot at the moving targets above and try to hit them, to gain as many points as possible with 10 shots. If you hit the blue space ship you get 10 pts and if you hit the red space ship you get 5 pts. Keep shooting until your shots are over and try to get as many points as possible with your shots. Have fun!
The program, in addition to being a spaceship arcade game also has some creative visuals the user will enjoy. When the users hit a certain target the program moves into a scene function. Each scene function is different; while one is a scene of an explosion, another scene is of a spaceship shooting at the target in an automated and very dramatical way (so that it looks cool). 

How the program is structured, from the programmers perspective.
From the programmers perspective, the game is run in graphics with one main driver. Inside the driver the program runs within a while loop. Furthermore, the program contains various functions that emcompass most of what the program does. Within the while loop in the main driver, the functions are called to display the different graphics such as the ship, background and UFOs. The UFOs move by recursively iterating their position. Now, if a shot is fired the program checks if it hits an UFO by tracking the position of the shot and calling the function checkHit to check for the distance between the center of the shot and the center of the UFOs. If this distance is small enough, then that means the UFO has been hitted, and the counter for the score is incresed depending on what UFO you hit. Similarly, depending on what UFO was hitten we either call explosion 1 or explosion 2 function, which are creative visuals. Within these functions we also made use of graphics to display the explosion, which is the first scene and the dramatic scene previously described. It's important to recall that the second scene also calls the first scene to display the explotion. It is important to mention that the program keep track of the score and displays it on the top right corner as well as the number of shots on the top left corner.
Finally, the game ends when 10 shots have been fired ie when the counter for the times that a shot was fired reaches its maximum. At this point the program breaks out of the main while loop within the main driver and the graphics window closes. The score is then displayed in the terminal.

How you evaluated the program for correctness. Did you verify that it produces correct results? Are there any cases where it produces incorrect results? Why?
We evaluated this program for correctness using various methods to solve different issues. At first, while we were coding the program essentials, such as the ship and its targets, we were evaluating for correctness using the usleep() method. By increasing the usleep() time we were able to see more in detail the movement of each and every element and were able to diagnose the issues or discard them faster. Afterwards, for when we were evaluating the individual scenes after a shot hit one of the targets, we decided to evaluate for correctness by having the velocity motion of both balls start and stay in 0. By doing this were able to quickly shoot at it, hit it, and also jump into the scene that we were evaluating for correctness at the time using the original method of having a high time for usleep(). Also, it is important to mention that to check for the position of the objects and cases we used if-else if statements. Towards the end of the program, we would sometimes implement both evaluating methods (usleep() and velocity=0) at the same time to evaluate special cases. Such cases could include: evaluating special cases where the shot hit the targets, and studying the scenes to ensure correctness. After extensive debugging and program evaluation, we found that there are no errors with the program and there are no instances where incorrect result are produced. 

Disclaimer: For compiling use g++ -std=c++11 final.cpp gfxnew.o -lX11 -o ex1
When compiling we will get a lot of warnings since we used the XPoint structure. We get the following warning
final.cpp:373:40: warning: narrowing conversion of ‘(y + 10)’ from ‘int’ to ‘short int’ inside { } [-Wnarrowing]
   XPoint b[] = {x,y+10,x-20,y+35,x-20,y+10};
