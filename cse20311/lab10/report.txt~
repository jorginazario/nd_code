What your program from part 3 is meant to do, from the user's perspective:
From the user's perspective this program is a game. The game consists of the two initial pieces in motion. The bottom black circle moving from side to side will be the "shooting ball" and the top red circle in rotational motion will be the target. The user game rules are the following: click 's' in the keyboard to shoot the bottom black ball at the top red spinning ball.If the two circles do not collide, both will restart to their original motions in the original positions. However, if the balls collide, there will be an explosion of figures will occur (a square sliding diagonally into one corner of the screen and a triangle sliding diagonally into another corner of the screen).

How the program is structured, from the programmer's perspective:
From the programmer's perspective the program is structured in three fundamental functions: 1) Main function 2)Motion function 3)figureExplosion function. The main function's primary role is to include the motion of the bottom black ball movement upwards into the target and the different cases for which the two circles can collide. The Motion function will do most of the program's work by making the target move in a rotational motion and the bottom black ball form side to side. Finally, we have the figureExplosion function, which comes into play after the collision of the two circles, and shoots two different figures into two different corners (resembeling an explosion).

How you evaluated the program for correctness. Did you verify that it produces correct results? Are there any cases where it produces incorrect results? Why?
I evaluated this program for correctness by increasing the usleep() time and ensuring I tested for the three different possible cases for collision between the two circles. I also evaluated for correctness by playing the game myself for a while and ensuring that the game never bugged with special cases. I decided to do it this way because by slowing the speed of the two circle I found that it was much easier to see when the circles would collide, and I could manipulate the circles to collide in the three different cases to test for them for correctness. After all the debugging, there were no errors with the program.
